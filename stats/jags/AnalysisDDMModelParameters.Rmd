
# Perform analyses on response variables and parameters
```{r}
rm(list = ls())
source("../analysis_funcs.R")

statslist = list()

WD = '../../data'
WDD = file.path(WD, 'experiment')
mytheme = theme_classic(base_size = 13) + theme(legend.position = 'bottom', legend.title = element_blank())
theme_set(mytheme)
# Load previous fit
MYFILE = '../results/linear_drift_ddm-02-05-2022_00:03-10000-50000-jags-pars.RData'
load(MYFILE)
numSubjs = dataList$N

# Load data
load(file.path(WDD, "processed_data_censored.RData"))
grouping_var = 'subj_context'
choicedata.common$subj_context = paste(choicedata.common$subjID, choicedata.common$context)
dataList = organize_data(choicedata.common, grouping_var, long = T)
subjList <-
  unique(choicedata.common[c('subjID',
                             'context',
                             'context_num',
                             'context_order',
                             'background_col',
                             grouping_var)])

choicedata.common = choicedata.common %>% mutate(
  Context = ifelse(context == 'c1', 'High volatility', 'Low volatility'),
  Choice = ifelse(choice == 1, 'Later option', 'Immediate option'),
  Context_order = ifelse(context_order == 1, 'First context', 'Second context'),
  Group =  ifelse(
    context_order == 1 &
      context == 'c1' |
      context_order == 2 & context == 'c2' ,
    'High vol. first',
    'Low vol. first'
  )
)

ratingdata.sub = ratingdata.sub %>% mutate(
  Context = ifelse(context == 'c1', 'High volatility', 'Low volatility'),
  Context_order = ifelse(context_order == 1, 'First context', 'Second context'),
  key.rt = key.rt/1000,
  Group =  ifelse(
    context_order == 1 &
      context == 'c1' |
      context_order == 2 & context == 'c2' ,
    'High vol. first',
    'Low vol. first'
  )
)
```

# Extract parameters
```{r}
numPars <- 5

# Individual parameters (e.g., individual posterior means)
allIndPars <- array(NA, c(numSubjs, numPars))
allIndPars <- as.data.frame(allIndPars)

for (i in 1:numSubjs) {
  allIndPars[i, ] <- c(
    mean(parVals$b.drift.intercept.p[i, ]),
    mean(parVals$b.drift.amount.p[i, ]),
    mean(parVals$bias.p[i, ]),
    mean(parVals$nondectime.p[i, ]),
    mean(parVals$noise.p[i, ])
  )
}

allIndPars = cbind(allIndPars, subjList[-ncol(subjList)])

colnames(allIndPars) <- c(
  "b.drift.intercept.p",
  "b.drift.amount.p",
  "bias.p",
  "nondectime.p",
  "noise.p",
  "subjID",
  "context",
  "context_num",
  "context_order",
  "background_col"
)

allIndPars = allIndPars %>% mutate(
  Context = ifelse(context == 'c1', 'High volatility', 'Low volatility'),
  Context_short = ifelse(context == 'c1', 'High', 'Low'),
  Context_order = ifelse(context_order == 1, 'First context', 'Second context'),
  Group =  ifelse(
    context_order == 1 &
      context == 'c1' |
      context_order == 2 & context == 'c2' ,
    'High vol. first',
    'Low vol. first'
  )
)
```

# Remove subjects if they have low sensitivity
```{r}
Rhat = max(myfit_summary[, 'psrf'])
print(Rhat)

g = grep("b.drift.amount.p\\[", rownames(myfit_summary))
allIndPars$lower_bound = myfit_summary[g, 'Lower95']
allIndPars$upper_bound = myfit_summary[g, 'Upper95']
allIndPars$Median = myfit_summary[g, 'Median']
allIndPars$b.drift.amount.p.0 = allIndPars$lower_bound > 0 |
  allIndPars$upper_bound < 0

plot(
  allIndPars$lower_bound[order(allIndPars$lower_bound)],
  type = 'l',
  ylim = c(min(allIndPars$lower_bound), max(allIndPars$upper_bound)),
  xlab = "Subject/Context",
  ylab = "5%-quantile for drift sensitivity"
)
#lines(allIndPars$upper_bound[order(allIndPars$lower_bound)]  , type = 'l')
abline(0, 0, col = 'red')
```

# Keep only subjects with a significant relationship between drift and value
```{r, fig.width = 15}
allIndPars$index = seq(nrow(allIndPars))

allIndPars.subj = allIndPars %>% group_by(subjID) %>% summarise(keep = max(lower_bound) > 0) %>% filter(keep) %>% ungroup()
include_subjects = allIndPars.subj$subjID

allIndPars.sub = subset(allIndPars, subjID %in% include_subjects)
```

# Remove outliers
```{r}
#allIndPars = allIndPars %>% filter(nondectime.p < 2)
```



## Group distributions for parameters
```{r}
for (var in c("context",  "background_col", "context_order"))
{
  get_par_jags("b.drift.intercept.p", var)
  get_par_jags("b.drift.amount.p", var)
  get_par_jags("bias.p", var)
  get_par_jags("nondectime.p", var)
  get_par_jags("noise.p", var)
}

get_par_jags("b.drift.intercept.p", var2 = "Context", var = "context_order")
get_par_jags("b.drift.amount.p", var2 = "Context", var = "context_order")
get_par_jags("bias.p", var2 = "Context", var = "context_order")
get_par_jags("nondectime.p", var2 = "Context", var = "context_order")
get_par_jags("noise.p", var2 = "Context", var = "context_order")

context_sigmas = c(5, 2, 1)

allIndPars$context_sigma = context_sigmas[allIndPars$context_num]

mypars = c("b.drift.intercept.p",
           "b.drift.amount.p",
           "bias.p",
           "nondectime.p",
           "noise.p")

for (mypar in mypars) {
  print("------------------------------------")
  print(mypar)
  myform = formula(paste(
    mypar,
    "context + context_order + background_col + (1|subjID)",
    sep = "~"
  ))
  model = lmer(myform, data = allIndPars %>% filter(subjID %in% include_subjects))
  print(summary(model))
} 
```


## Plot RTs in relation to estimated subjective value
```{r}
source('./RTanalysis.R')
```

## Check distribution of context order and Context
```{r}
choicedata.order = choicedata %>% group_by(subjID) %>% slice_head(n=1) 
choicedata.order = choicedata.order %>% group_by(Context, context, context_order, Context_order) %>% summarise(size = n())
print(choicedata.order)
```

## Check probabilities

```{r}
source('./ChoiceAnalysis.R')
```


## Plot ratings in relation to estimated subjective value
```{r}
source('./RatingAnalysis.R')
```

## Rating RT
```{r}
# remove outliers?
source("./RatingRTanalysis.R")

```

## Random slopes of ratings vs DDM parameters

```{r}
rating_par_names = c("bid.diff" = "WTP range", "key.rt" = "WTP response time")
choice_par_names = c("b.drift.intercept.p" = "Drift intercept", "b.drift.amount.p" = "Drift sensitivity",
                        "noise.p" = "Noise", "bias.p" = "Bias",
                        "nondectime.p" = "Non-decision time"
                      )

main.mat = inter.mat = NULL
#*Group*Context
mypars.rating = c("bid.diff", "key.rt")
for (mypar.rating in mypars.rating){
for (mypar in mypars){
  for (co in c(1, 2)){
     myformula = as.formula(sprintf("%s ~ scale(%s)*amount_later + Context + (1| subjID)", mypar.rating, mypar)) 
     model = lmer(myformula, data = ratingdata %>% filter(context_order == co))
     ss = summary(model)
     print(myformula)
     print(ss)
     ss.1 = coef(ss)[sprintf("scale(%s)", mypar), c("Estimate", "t value", "df", "Pr(>|t|)")]
     ss.2 = coef(ss)[sprintf("scale(%s):amount_later", mypar), c("Estimate", "t value", "df", "Pr(>|t|)")]
     main.mat = rbind(main.mat, c(mypar.rating, mypar, co, round(ss.1, 3)))
     inter.mat = rbind(inter.mat, c(mypar.rating, mypar, co, round(ss.2, 3)))
  }
  myplot.rating.pars = ggplot(data = ratingdata, aes(
  x = eval(mypar.rating),
  y = eval(mypar),
  color = Context_order,
  group = subjID
)) +
  geom_line(size = 0.5, alpha = 0.4) +
  geom_point(size = 0.5, alpha = 0.4) +
  xlab('Subjective value of later amount ($)') +
  ylab('Willingness-to-pay range ($)') + facet_grid(. ~ Context_order)
print(myplot.rating.pars)

  } 
} 
main.mat = as.data.frame(main.mat)
inter.mat = as.data.frame(inter.mat)##
main.mat = main.mat%>% mutate(V1 = rating_par_names[as.character(V1)], V2 = choice_par_names[as.character(V2)])
inter.mat = inter.mat%>% mutate(V1 = rating_par_names[as.character(V1)], V2 = choice_par_names[as.character(V2)])

colnames(main.mat) = colnames(inter.mat) = c("WTP parameter", "DDM parameter", "Context order", "Estimate", "t", "df", "p-value")
View(main.mat)
View(inter.mat)

#myplot.main.intercept = ggplot(ratingdata, aes(x = jitter(amount_later), y = b.drift.intercept.p, col = bid.diff )) + geom_point() + scale_color_viridis_c()
#print(myplot.main.intercept)
#myplot.main.amount = ggplot(ratingdata, aes(x = jitter(amount_later), y = b.drift.amount.p, col = bid.diff )) + geom_point() + scale_color_viridis_c()
#print(myplot.main.amount)
statslist['_table_range_main_'] = tab_to_str(main.mat)
statslist['_table_range_inter_'] = tab_to_str(inter.mat)

#ratingdata.melt = melt(ratingdata, measure.vars = mypars.rating, variable.name = "Parameter")



```


## Mediation of DDM parameters

```{r}
library(mediation)
detach(package:lmerTest)
# rating_par_names = c("bid.diff" = "WTP range", "key.rt" = "WTP response time")
# choice_par_names = c("b.drift.intercept.p" = "Drift intercept", "b.drift.amount.p" = "Drift sensitivity",
#                         "noise.p" = "Noise", "bias.p" = "Bias",
#                         "nondectime.p" = "Non-decision\ntime"
#                       )

acme.mat = prop.mat = NULL
#*Group*Context
mypars.rating = c("bid.diff", "key.rt")
for (mypar.rating in mypars.rating){
for (mypar in mypars){
     ratingdata$mediator = scale(ratingdata[mypar])
     myformula.m = as.formula("mediator ~  Context*Group + (1| subjID)")
     model.m = lmer(myformula.m, data = ratingdata )
     if (mypar.rating == 'bid.diff') 
       { 
       myformula.b = as.formula(sprintf("%s ~ mediator*amount_later_centered + Context*Group + (1| subjID)", mypar.rating, mypar))
       }
     else
       {
       myformula.b = as.formula(sprintf("%s ~ mediator + Context*Group + (1| subjID)", mypar.rating, mypar))
     } 
     model.b = lmer(myformula.b, data = ratingdata)
     med = mediate(model.m, model.b, treat = "Context", mediator = "mediator", boot = F,
                   control.value="Low volatility", treat.value="High volatility")
     #print(paste(mypar.rating, mypar))
     #print(c(med$d0, med$d0.ci, med$d0.p ))
     #print(c(med$tau.coef, med$tau.ci, med$tau.p ))
     #print(c(med$n0, med$n0.ci, med$n0.p ))
     
     ss.acme = c(med$d0, med$d0.ci[1], med$d0.ci[2], med$d0.p)
     #ss. = c(med$tau.coef, med$tau.ci[0], med$tau.ci[1], med$tau.p)
     ss.prop = c(med$n0, med$n0.ci[1], med$n0.ci[2], med$n0.p)
     acme.mat = rbind(acme.mat, c(mypar.rating, mypar, round(ss.acme, 3)))
     prop.mat = rbind(prop.mat, c(mypar.rating, mypar, round(ss.prop, 3)))
  }
}

acme.mat = as.data.frame(acme.mat)
prop.mat = as.data.frame(prop.mat)##
acme.mat = acme.mat%>% mutate(V1 = rating_par_names[as.character(V1)], V2 = choice_par_names[as.character(V2)])
prop.mat = prop.mat%>% mutate(V1 = rating_par_names[as.character(V1)], V2 = choice_par_names[as.character(V2)])

colnames(acme.mat) = c("WTP parameter", "DDM parameter", "ACME Estimate", "ACME  CI 2.5%", "ACME CI 97.5%", "p-value")
colnames(prop.mat) = c("WTP parameter", "DDM parameter", "Proportion Estimate", "Proportion CI 2.5%", "Proportion CI 97.5%", "p-value")
View(acme.mat)
View(prop.mat)

library(lmerTest)
mediation.mat = cbind(acme.mat[, -6], prop.mat[, seq(3, 6)] )
mediation.mat = subset(mediation.mat, `WTP parameter` == 'WTP response time')[-1] 

statslist['_table_mediation_'] = tab_to_str(mediation.mat)
statslist['_prop_drift_intercept_'] = as.numeric(as.character(mediation.mat[1, 5]))*100
statslist['_prop_nondectime_'] = as.numeric(as.character(mediation.mat[4, 5]))*100
statslist['_prop_noise_'] = as.numeric(as.character(mediation.mat[5, 5]))*100

```

# Parameter tests
```{r, fig.width = 15}
source('./ParameterAnalysis.R')
```



```{r, fig.width = 15}
# Standard error of the mean
myplot = ggplot(allIndPars.sum, aes(x=parameter, y=value)) + 
    geom_errorbar(aes(ymin = value-se, ymax = value+se), width=.1) +
    geom_line() +
    geom_point() + 
    ylab('Parameter difference (low volatility - high volatility)') + 
    geom_hline(yintercept = 0, col = 'red')
print(myplot)

```

## Check correlation between parameters

```{r, fig.width = 15}


options(width = 300)

mydata = allIndPars %>% filter(subjID %in% include_subjects  & nondectime.p < 2)
cor(mydata[mypars])
pairs(mydata[mypars])
mydata$GroupContext = paste(mydata$Group, mydata$Context, sep = " - ")

myplot.pairs <- ggpairs(mydata, columns = mypars, ggplot2::aes(colour=GroupContext), columnLabels = par_labels, upper = list(continuous = wrap("cor", size=2)))
print(myplot.pairs)

```



```{r}

HEIGHT1ROW = 4.06
WIDTH1COL = 3.8
DPI = 1000

FIGS_DIR = '../figs'

#myplot.trial.RT

fig.a.1 = ggarrange(myplot.RT.choice.group, myplot.RT.choice.agg,
                   ncol=2, nrow=1, labels = c('A', 'B'))
fig.a.2 = ggarrange(myplot.trial.RT,
                   ncol=1, nrow=1, labels = c('C'))
fig.a.3 = ggarrange(myplot.choiceprob.group, myplot.choiceprob.agg,
                   ncol=2, nrow=1, labels = c('D', 'E'))

# fig.a = ggarrange(myplot.RT.choice.group, myplot.RT.choice.agg, 
#                    myplot.choiceprob.group, myplot.choiceprob.agg, 
#                    ncol=2, nrow=2, labels = c('A', 'B', 'C', 'D'))

fig.a = ggarrange(fig.a.1, fig.a.2, fig.a.3, 
                   ncol=1, nrow=3)

ggsave(filename=file.path(FIGS_DIR, "Choices.png"), plot = fig.a, dpi = DPI, 
       width = WIDTH1COL*2, height = HEIGHT1ROW*3)

fig.b = ggarrange(myplot.differences.all, myplot.differences.agg, ncol=1, nrow=2, labels = c('A', 'B'))
#fig.a = ggarrange(fig.a1, fig.a2, ncol=1, nrow=2, heights = c(1, 1))

ggsave(filename=file.path(FIGS_DIR, "Parameters.png"), plot = fig.b, dpi = DPI, width = WIDTH1COL*2, height = HEIGHT1ROW*2)


fig.c = ggarrange(myplot.range.group, myplot.range.agg, 
                  myplot.key.rt.group, myplot.key.rt.agg, 
                  ncol=2, nrow=2, labels = c('A', 'B', 'C', 'D'))
ggsave(filename=file.path(FIGS_DIR, "Ratings.png"), plot = fig.c, dpi = DPI, width = WIDTH1COL*2, height = HEIGHT1ROW*2)

ggsave(filename=file.path(FIGS_DIR, "ParameterCorrelations.png"), plot = myplot.pairs, dpi = DPI, width = WIDTH1COL*2, height = HEIGHT1ROW*2)

print(fig.a)
print(fig.b)
print(fig.c)

```



```{r}
filein = '../results/results_text.txt'
fileout = '../results/results_text_fixed.txt'
text = readLines(filein)
print(statslist)
text.new = NULL
placeholders = names(statslist)
for (line in text){ 
for (placeholder in placeholders){
  line = gsub(placeholder, replacement = statslist[placeholder], line)
}
text.new = c(text.new, line)

}
unlink(fileout)
writeLines(text.new, con = fileout)
```

