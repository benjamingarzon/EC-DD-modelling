---
title: "Analysis"
output: html_document
---

# Perform analyses on response variables and DDM parameters

```{r}
rm(list = ls())
source("../analysis_funcs.R")

WD = '../../data'
WDD = file.path(WD, 'experiment')
mytheme = theme_classic(base_size = 11) + theme(legend.position = 'bottom', legend.title = element_blank())
theme_set(mytheme)
MYFILE = '../results/linear_drift_no_pooling_ddm-processed_data_balanced_censored-08-08-2025_14:53-20000-50000-jags-pars.RData'
load(MYFILE)
load(file.path(WDD, "processed_data_balanced_censored.RData"))
IMAGE_FILE = file.path("../results/AnalysisDDMModelParameters_workspace")

numSubjs = dataList$N

grouping_var = 'subj_context'
choicedata.common$subj_context = paste(choicedata.common$subjID, choicedata.common$context)
dataList = organize_data(choicedata.common, grouping_var, long = T)
subjList <-
  unique(choicedata.common[c('subjID',
                             'context',
                             'context_num',
                             'context_order',
                             'background_col',
                             grouping_var)])

choicedata.common = choicedata.common %>% mutate(
  Context = ifelse(context == 'c1', 'High volatility', 'Low volatility'),
  Choice = ifelse(choice == 1, 'Later option', 'Immediate option'),
  Context_order = ifelse(context_order == 1, 'First context', 'Second context'),
  Group =  ifelse(
    context_order == 1 &
      context == 'c1' |
      context_order == 2 & context == 'c2' ,
    'High vol. first',
    'Low vol. first'
  ),
  log_rt = log(rt)
)

ratingdata.sub = ratingdata.sub %>% 
  mutate(  key.rt.orig = key.rt) %>%
  mutate(
  Context = ifelse(context == 'c1', 'High volatility', 'Low volatility'),
  Context_order = ifelse(context_order == 1, 'First context', 'Second context'),
  Group =  ifelse(
    context_order == 1 &
      context == 'c1' |
      context_order == 2 & context == 'c2' ,
    'High vol. first',
    'Low vol. first'
  ),
  key.rt = bid.rt.max,
  log_key.rt = log(bid.rt.max)

)

```

# Extract parameters
```{r}

numPars <- 5
# Individual parameters (e.g., individual posterior means)
allIndPars <- array(NA, c(numSubjs, numPars))
allIndPars <- as.data.frame(allIndPars)

for (i in 1:numSubjs) {
  allIndPars[i,] <- c(
    mean(parVals$b.drift.intercept.p[i,]),
    mean(parVals$b.drift.amount.p[i,]),
    mean(parVals$bias.p[i,]),
    mean(parVals$nondectime.p[i,]),
    mean(parVals$noise.p[i,])
  )
}

allIndPars = cbind(allIndPars, subjList[-ncol(subjList)])

colnames(allIndPars) <- c(
  "b.drift.intercept.p",
  "b.drift.amount.p",
  "bias.p",
  "nondectime.p",
  "noise.p",
  "subjID",
  "context",
  "context_num",
  "context_order",
  "background_col"
)

allIndPars = allIndPars %>% mutate(
  Context = ifelse(context == 'c1', 'High volatility', 'Low volatility'),
  Context_short = ifelse(context == 'c1', 'High', 'Low'),
  Context_order = ifelse(context_order == 1, 'First context', 'Second context'),
  Group =  ifelse(
    context_order == 1 &
      context == 'c1' |
      context_order == 2 & context == 'c2' ,
    'High vol. first',
    'Low vol. first'
  )
)
```

# Remove subjects if they have low sensitivity
```{r}
Rhat = max(myfit_summary[, 'psrf'])
print(Rhat)

g = grep("b.drift.amount.p\\[", rownames(myfit_summary))
allIndPars$lower_bound = myfit_summary[g, 'Lower95']
allIndPars$upper_bound = myfit_summary[g, 'Upper95']
allIndPars$Median = myfit_summary[g, 'Median']
allIndPars$b.drift.amount.p.0 = allIndPars$lower_bound > 0 |
  allIndPars$upper_bound < 0

plot(
  allIndPars$lower_bound[order(allIndPars$lower_bound)],
  type = 'l',
  ylim = c(min(allIndPars$lower_bound), max(allIndPars$upper_bound)),
  xlab = "Subject/Context",
  ylab = "5%-quantile for drift sensitivity"
)
#lines(allIndPars$upper_bound[order(allIndPars$lower_bound)]  , type = 'l')
abline(0, 0, col = 'red')
```

# Keep only subjects with a significant relationship between drift and value
```{r, fig.width = 15}
allIndPars$index = seq(nrow(allIndPars))

allIndPars.subj = allIndPars %>% group_by(subjID) %>% summarise(keep = max(lower_bound) > 0) %>% filter(keep) %>% ungroup()
include_subjects = allIndPars.subj$subjID

allIndPars.sub = subset(allIndPars, subjID %in% include_subjects)

write.table(include_subjects, file = file.path(WDD, 'final_subjects_included.txt'), row.names = F, col.names=F, quote = F)
```

# Remove outliers
```{r}
#allIndPars = allIndPars %>% filter(nondectime.p < 2)
```



# Group distributions for parameters
```{r Group distributions}
for (var in c("context",  "background_col", "context_order"))
{
  get_par_jags("b.drift.intercept.p", var)
  get_par_jags("b.drift.amount.p", var)
  get_par_jags("bias.p", var)
  get_par_jags("nondectime.p", var)
  get_par_jags("noise.p", var)

  }

get_par_jags("b.drift.intercept.p", var2 = "Context", var = "context_order")
get_par_jags("b.drift.amount.p", var2 = "Context", var = "context_order")
get_par_jags("bias.p", var2 = "Context", var = "context_order")
get_par_jags("nondectime.p", var2 = "Context", var = "context_order")
get_par_jags("noise.p", var2 = "Context", var = "context_order")

context_sigmas = c(5, 2, 1)

allIndPars$context_sigma = context_sigmas[allIndPars$context_num]

mypars = c("b.drift.intercept.p",
           "b.drift.amount.p",
           "bias.p",
           "nondectime.p",
           "noise.p")

for (mypar in mypars) {
  print("------------------------------------")
  print(mypar)
  myform = formula(paste(
    mypar,
    "context + (1|subjID)", #  + background_col+ context_order 
    sep = "~"
  ))
  model = lmer(myform, data = allIndPars %>% filter(subjID %in% include_subjects))
  print(summary(model))
} 
```

```{r}


breaks = seq(0.5, 8.5, 1)
choicedata = merge(
  choicedata.common,
  allIndPars %>% filter(subjID %in% include_subjects),
  by = c(
    'subjID',
    'Context',
    'context',
    'Context_order',
    'background_col',
    'context_order',
    'Group'
  )
)
choicedata = choicedata %>% mutate(ev = amount_later, context_num = as.numeric(substr(context, 2, 2))) %>% mutate(ev.cut = cut(ev, breaks))

choicedata.median = choicedata %>%
  group_by(subjID,
    Context,
    context,
    Context_order,
    context_order,
    Group,
    ev.cut) %>%
  dplyr::summarise(
    rt.median = median(rt),
    ev = mean(ev),
    prob_late = mean(choice)
  )

choicedata.group = choicedata.median %>%
  group_by(Context, Context_order, ev.cut, Group) %>%
  dplyr::summarise(
    rt.mean = mean(rt.median),
    rt.sem = sem(rt.median),
    prob_late.mean = mean(prob_late),
    prob_late.sem = sem(prob_late),
    ev = mean(ev)
  )

```



# Plot RTs in relation to estimated subjective value
```{r RT analysis}
source('./RTanalysis.R')
```

# Check distribution of context order and context
```{r}
choicedata.order = choicedata %>% group_by(subjID) %>% slice_head(n=1) 
choicedata.order = choicedata.order %>% group_by(Context, context, context_order, Context_order) %>% summarise(size = n())
print(choicedata.order)
```

```{r Save all 0}
save.image(file = paste0(IMAGE_FILE, "_0.RData"))
```


# Check response probabilities
```{r Choice analysis}
source('./ChoiceAnalysis.R')
```

```{r Save all 1}
save.image(file = paste0(IMAGE_FILE, "_1.RData"))
```

# Analyze ratings
```{r Rating analysis}
source('./RatingAnalysis.R')
```

```{r Save all 2}
save.image(file = paste0(IMAGE_FILE, "_2.RData"))
```


# Difference in ratings vs difference in DDM parameters
```{r Differences}

rating_par_names = c("bid.diff" = "WTP range",
                     "log_key.rt" = "(log) WTP response time",
                     "bid.rt.max" = "Max response time")
choice_par_names = c(
  "b.drift.intercept.p" = "Drift intercept",
  "b.drift.amount.p" = "Drift sensitivity",
  "noise.p" = "Noise",
  "bias.p" = "Bias",
  "nondectime.p" = "Non-decision time",
  "sigma.p" = "Drift sd"
)
# Check differences

ratingdata.high <- ratingdata %>% 
  filter(context == 'c1')
ratingdata.low <- ratingdata %>% 
  filter(context == 'c2')

cols <- c("subjID", "ev", "amount_later_centered", "b.drift.intercept.p", "log_key.rt",
  "b.drift.amount.p", "bias.p", "nondectime.p", "noise.p", "bid.diff", "Group")

ratingdata.all <- merge(ratingdata.high[cols], ratingdata.low[cols], by = c('subjID', 'ev', 'amount_later_centered'), suffix = c('.high', '.low')) 

# compute differences high vs low
ratingdata.all <- ratingdata.all %>% mutate(
  log_key.rt = log_key.rt.high - log_key.rt.low, bid.diff = bid.diff.high - bid.diff.low, 
  b.drift.amount.p = b.drift.amount.p.high - b.drift.amount.p.low,
  b.drift.intercept.p = b.drift.intercept.p.high - b.drift.intercept.p.low,
  nondectime.p = nondectime.p.high - nondectime.p.low,
  noise.p = noise.p.high - noise.p.low,
  bias.p = bias.p.high - bias.p.low
  ) %>% mutate(Group = Group.low)

mypars.rating = c("bid.diff", "log_key.rt") 

main.mat = inter.mat =  NULL

for (mypar.rating in mypars.rating) {
for (co in c("High vol. first", "Low vol. first")) {
for (mypar in mypars) {
myformula <- as.formula(
  sprintf(
    "%s ~ %s*amount_later_centered + (1 + amount_later_centered| subjID)",
    mypar.rating,
    mypar
  )
)

pars <- c(mypar, sprintf("%s:amount_later_centered", mypar))
names(pars) <- c(sprintf("_diff_%s_%s_%s_main_", mypar.rating, mypar, co), sprintf("_diff_%s_%s_%s_inter_", mypar.rating, mypar, co))
model <- fitmodel(myformula, ratingdata.all %>% filter(Group == co), pars)

ss <- summary(model)
print(myformula)
print(ss)
# Extract posterior means and summary statistics for fixed effects
fe_summary <- get_fixef(model)
ss.1 <- fe_summary[mypar, ]
ss.2 <- fe_summary[sprintf("%s:amount_later_centered", mypar), ] 
main.mat <- rbind(main.mat, c(mypar.rating, mypar, co, ss.1))
inter.mat <- rbind(inter.mat, c(mypar.rating, mypar, co, ss.2))
}
}
}

main.mat = as.data.frame(main.mat)
inter.mat = as.data.frame(inter.mat)

main.mat = as.data.frame(main.mat)
inter.mat = as.data.frame(inter.mat)
main.mat = main.mat %>% arrange(V1, V2)
inter.mat = inter.mat %>% arrange(V1, V2)
main.mat = main.mat %>% mutate(V1 = rating_par_names[as.character(V1)], V2 = choice_par_names[as.character(V2)])
inter.mat = inter.mat %>% mutate(V1 = rating_par_names[as.character(V1)], V2 = choice_par_names[as.character(V2)])

main.mat <- add_ci_column(main.mat)
inter.mat <- add_ci_column(inter.mat)

colnames(main.mat) = colnames(inter.mat) = c("WTP parameter",
                                             "DDM parameter",
                                             "Group",
                                             "Estimate",
                                             "Est.Error", 
                                             "95% CI"
  )

main.mat = main.mat %>% relocate(Group) %>% arrange(`Group`, `WTP parameter`,
                                             `DDM parameter`,
                                             )
inter.mat = inter.mat %>% relocate(Group) %>% arrange(`Group`, `WTP parameter`,
                                             `DDM parameter`,
                                             )

#View(main.mat)
#View(inter.mat)

statslist['_table_diff_main_'] = tab_to_str(main.mat)
statslist['_table_diff_inter_'] = tab_to_str(inter.mat)


```

```{r Save all 3}
save.image(file = paste0(IMAGE_FILE, "_3.RData"))
```


# Rating RT
```{r Rating RT}
source("./RatingRTanalysis.R")

```

```{r Save all 4}
save.image(file = paste0(IMAGE_FILE, "_4.RData"))
```

# Rating parameters vs DDM parameters

```{r Slopes vs parameters}
rating_par_names = c("bid.diff" = "WTP range",
                     "log_key.rt" = "(log) WTP response time",
                     "bid.rt.max" = "Max response time")
choice_par_names = c(
  "b.drift.intercept.p" = "Drift intercept",
  "b.drift.amount.p" = "Drift sensitivity",
  "noise.p" = "Noise",
  "bias.p" = "Bias",
  "nondectime.p" = "Non-decision time",
  "sigma.p" = "Drift sd"
)

myplots.list = list()
j = 1
main.mat = inter.mat = NULL

ratingdata.subj = ratingdata %>% group_by(subjID, Context, Context_order) %>% summarise_at(c(mypars, mypars.rating), .funs = 'mean')

#*Group*Context
mypars.rating = c("bid.diff", "log_key.rt") 
for (mypar.rating in mypars.rating) {
  for (mypar in mypars) {
    for (co in c(1, 2)) {
      myformula = as.formula(
        sprintf(
          "%s ~ %s*amount_later_centered + (1 + amount_later_centered| subjID)",
          mypar.rating,
          mypar
        )
      )

      pars <- c(mypar, sprintf("%s:amount_later_centered", mypar))
      names(pars) <- c(sprintf("_range_%s_%s_%s_main_", mypar.rating, mypar, co), sprintf("_range_%s_%s_%s_inter_", mypar.rating, mypar, co))
      if (mypar == "nondectime.p"){
        model <- fitmodel(myformula, ratingdata %>% filter(context_order == co & nondectime.p < 2), pars)
      } else {
        model <- fitmodel(myformula, ratingdata %>% filter(context_order == co), pars)
      }

      ss <- summary(model)
      print(myformula)
      print(ss)
      # Extract posterior means and summary statistics for fixed effects
      
      fe_summary <- get_fixef(model)
      ss.1 <- fe_summary[mypar, ] 
      ss.2 <- fe_summary[sprintf("%s:amount_later_centered", mypar), ] 
      main.mat <- rbind(main.mat, c(mypar.rating, mypar, co, ss.1))
      inter.mat <- rbind(inter.mat, c(mypar.rating, mypar, co, ss.2))


  }
    
    if (mypar == "nondectime.p"){
        ratingdata.subj_ <- ratingdata.subj %>% filter(nondectime.p < 2)
        
    } else {
        ratingdata.subj_ <- ratingdata.subj
    }

    # Create plot with regression lines and correlations for each Context_order

    myplot.rating.pars = ggplot(data = ratingdata.subj_,
    aes_string(
      y = mypar.rating,
      x = mypar,
      color = 'Context',
      group = 'subjID'
    )) +
    geom_point() +
    stat_cor(aes(group = 1), show.legend = FALSE, label.x.npc = 0.5, label.y.npc = "top") + # Correlation in upper right of each facet
    geom_smooth(method = "lm", se = T, aes(group = 1)) +
    facet_grid(. ~ Context_order) +
    xlab(choice_par_names[mypar]) +
    ylab(rating_par_names[mypar.rating])
    print(myplot.rating.pars)
    myplots.list[[j]]  = myplot.rating.pars
    j = j + 1
  }
}
main.mat = as.data.frame(main.mat)
inter.mat = as.data.frame(inter.mat)
main.mat = main.mat %>% arrange(V1, V3, V2)
inter.mat = inter.mat %>% arrange(V1, V3, V2)
main.mat = main.mat %>% mutate(V1 = rating_par_names[as.character(V1)], V2 = choice_par_names[as.character(V2)])
inter.mat = inter.mat %>% mutate(V1 = rating_par_names[as.character(V1)], V2 = choice_par_names[as.character(V2)])

main.mat <- add_ci_column(main.mat)
inter.mat <- add_ci_column(inter.mat)

colnames(main.mat) = colnames(inter.mat) = c("WTP parameter",
                                             "DDM parameter",
                                             "Context order",
                                             "Estimate",
                                             "Est.Error", 
                                             "95% CI"
  )

#View(main.mat)
#View(inter.mat)

statslist['_table_range_main_'] = tab_to_str(main.mat)
statslist['_table_range_inter_'] = tab_to_str(inter.mat)


```


# Rating parameters vs DDM parameters; multiple regression

```{r Slopes vs parameters multiple reg}
# scale parameters, add simpler model

rating_par_names = c("bid.diff" = "WTP range",
                     "log_key.rt" = "(log) WTP response time",
                     "bid.rt.max" = "Max response time")
choice_par_names = c(
  "b.drift.intercept.p" = "Drift intercept",
  "b.drift.amount.p" = "Drift sensitivity",
  "noise.p" = "Noise",
  "bias.p" = "Bias",
  "nondectime.p" = "Non-decision time",
  "sigma.p" = "Drift sd"
)

model_names = c("Full" = "Full", "Reduced" = "Reduced", "Baseline" = "Baseline")

main.mat = inter.mat = R2.mat = NULL

ratingdata.subj = ratingdata %>% group_by(subjID, Context, Context_order) %>% summarise_at(c(mypars, mypars.rating), .funs = 'mean')
model_types = c("Full", "Reduced", "Baseline")

mypars.rating = c("bid.diff", "log_key.rt") 
for (model_type in model_types){
for (mypar.rating in mypars.rating) {
    for (co in c(1, 2)) {
      if (model_type =="Full"){
      selpars <- c(mypars, "amount_later_centered")
      myformula = as.formula(
        sprintf(
          "%s ~ (b.drift.intercept.p + b.drift.amount.p + noise.p + bias.p + nondectime.p)*amount_later_centered + (1 + amount_later_centered| subjID)",
          mypar.rating
        )
        
      )} else if (model_type =="Reduced") {
      selpars <- c("b.drift.intercept.p", "bias.p", "nondectime.p", "amount_later_centered")   
      myformula = as.formula(
        sprintf(
          "%s ~ (b.drift.intercept.p + bias.p + nondectime.p)*amount_later_centered + (1 + amount_later_centered| subjID)",
          mypar.rating
        )
      )

      } else {
      selpars <- c("amount_later_centered")   
      myformula = as.formula(
        sprintf(
          "%s ~ amount_later_centered + (1 + amount_later_centered| subjID)",
          mypar.rating
        )
      )

      }
      
      allpars <- NULL
      for (mypar in selpars) {
         pars <- c(mypar, sprintf("%s:amount_later_centered", mypar))
         names(pars) <- c(sprintf("_multiple_range_%s_%s_%s_main_", mypar.rating, mypar, co), sprintf("_multiple_range_%s_%s_%s_inter_", mypar.rating, mypar, co))
         pars <- c(mypar)
         names(pars) <- c(sprintf("_multiple_range_%s_%s_%s_main_", mypar.rating, mypar, co))
         allpars <- c(allpars, pars)
      }
      
      ratingdata_ <- ratingdata %>% filter(nondectime.p < 2) %>% mutate_at(c(mypars, "amount_later_centered"), scale) %>% filter(context_order == co)
      
      model <- fitmodel(myformula, ratingdata_ , allpars, add_ics=T)

      ss <- summary(model)
      print(myformula)
      print(ss)
      # Extract posterior means and summary statistics for fixed effects
      
      fe_summary <- get_fixef(model)
      fe_summary$co <- co
      fe_summary$model_type <- model_type
      fe_summary$mypar.rating <- mypar.rating
      fe_summary$predictor <- rownames(fe_summary)
      main.mat <- rbind(main.mat, fe_summary)
      R2.mat <- rbind(R2.mat, c(mypar.rating, model_type, co, model$bayes_R2, model$criteria$loo$estimates["looic", "Estimate"],
        model$criteria$loo$estimates["looic", "SE"]))

    }
  }
}

main.mat = as.data.frame(main.mat)
main.mat = main.mat[c(7, 6, 5, 8, 1, 2, 3, 4)]
colnames(main.mat) <- c("WTP parameter",
                        "Model",
                        "Context order",
                        "Predictor",
                        "Estimate",
                        "Est.Error", 
                        "Q2.5", 
                        "Q97.5"
  )

main.mat = main.mat %>% arrange(`WTP parameter`, `Context order`)
main.mat = main.mat %>% mutate(
  `WTP parameter` = rating_par_names[as.character(`WTP parameter`)], 
  Predictor = reg_labels[as.character(Predictor)],
  Model = model_names[as.character(Model)])

main.mat <- add_ci_column(main.mat)
rownames(main.mat) <- NULL

R2.mat = as.data.frame(R2.mat)
colnames(R2.mat) <- c("WTP parameter",
                      "Model",
                      "Context order",
                      "R2 Estimate",
                      "R2 Est.Error", 
                      "R2 Q2.5", 
                      "R2 Q97.5",
                      "LOOIC Estimate",
                      "LOOIC SE"
  )
R2.mat = R2.mat %>% arrange(`WTP parameter`, `Context order`)
R2.mat = R2.mat %>% mutate(`WTP parameter` = rating_par_names[as.character(`WTP parameter`)], Model = model_names[as.character(Model)])
R2.mat = apply(R2.mat, 2, reformat)
R2.mat = as.data.frame(R2.mat)
R2.mat <- add_ci_column(R2.mat, lower="R2 Q2.5", upper="R2 Q97.5", colname="R2 95% CI")[c(1,2,3,4,5,8,6,7)]



#View(main.mat)
#View(inter.mat)

statslist['_table_multiple_range_main_'] = tab_to_str(main.mat)
statslist['_table_multiple_range_R2_'] = tab_to_str(R2.mat)


```

# Parameter tests
```{r Parameter analysis, fig.width = 15}
source('./ParameterAnalysis.R')
```

```{r Save all 5}
save.image(file = paste0(IMAGE_FILE, "_5.RData"))
```


```{r, fig.width = 15}
# Standard error of the mean
myplot = ggplot(allIndPars.sum, aes(x=parameter, y=value)) + 
    geom_errorbar(aes(ymin = value-se, ymax = value+se), width=.1) +
    geom_line() +
    geom_point() + 
    ylab('Parameter difference (low volatility - high volatility)') + 
    geom_hline(yintercept = 0, col = 'red')
print(myplot)

```

# Check correlation between parameters

```{r Parameter correlations, fig.width=15}
options(width = 300)

mydata = allIndPars %>% filter(subjID %in% include_subjects  &
                                 nondectime.p < 2)
cor(mydata[mypars])
pairs(mydata[mypars])

mydata = mydata %>% mutate(
  Context_tag = ifelse(Context_short == 'High', 'HV', 'LV'),
  Group_tag = ifelse(Group == 'High vol. first', 'HF', 'LF')
)

mydata$GroupContext = paste(mydata$Group_tag, mydata$Context_tag, sep = " - ")

myplot.pairs <-
  ggpairs(
    mydata,
    columns = mypars,
    ggplot2::aes(colour = GroupContext),
    columnLabels = par_labels,
    upper = list(continuous = wrap("cor", size = 3.5))
  ) +
  theme (strip.text = element_text (size = 12))
print(myplot.pairs)

```

# Make figures

```{r Make figs}


HEIGHT1ROW = 4.06
WIDTH1COL = 3.8
DPI = 1000

FIGS_DIR = '../figs'

#myplot.trial.RT

fig.a.1 = ggarrange(
  myplot.RT.choice.group,
  myplot.RT.choice.agg,
  ncol = 2,
  nrow = 1,
  labels = c('A', 'B')
)
fig.a.2 = ggarrange(
  myplot.trial.RT,
  ncol = 1,
  nrow = 1,
  labels = c('C')
)
fig.a.3 = ggarrange(
  myplot.choiceprob.group,
  myplot.choiceprob.agg,
  ncol = 2,
  nrow = 1,
  labels = c('D', 'E')
)

fig.a.4 = ggarrange(
  myplot.choiceprob.diff.group,
  myplot.choiceprob.diff.agg,
  ncol = 2,
  nrow = 1,
  labels = c('F', 'G')
)

# 
# fig.a.2 = ggarrange(
#   myplot.RT.choice.group,
#   myplot.RT.choice.agg,
#   myplot.choiceprob.group,
#   ncol = 3,
#   nrow = 1,
#   labels = c('B', 'C', 'D')
# )
# fig.a.3 = ggarrange(
#   myplot.choiceprob.agg,
#   myplot.choiceprob.diff.group,
#   myplot.choiceprob.diff.agg,
#   ncol = 3,
#   nrow = 1,
#   labels = c('E', 'F', 'G')
# )
# 

# fig.a = ggarrange(myplot.RT.choice.group, myplot.RT.choice.agg,
#                    myplot.choiceprob.group, myplot.choiceprob.agg,
#                    ncol=2, nrow=2, labels = c('A', 'B', 'C', 'D'))

fig.a.l = ggarrange(fig.a.2, fig.a.3, fig.a.4,
                  ncol = 3, nrow = 1)

fig.a = ggarrange(fig.a.1, fig.a.2, fig.a.3, fig.a.4,
                   ncol = 1, nrow = 4)

#fig.a = ggarrange(fig.a.1, fig.a.l,
#                  ncol = 1, nrow = 2, heights = c(1, 2))

# fig.a = ggarrange(fig.a.1, fig.a.2, fig.a.3, 
#                   ncol = 1, nrow = 3)

ggsave(
  filename = file.path(FIGS_DIR, "Choices.png"),
  plot = fig.a,
  dpi = DPI,
  width = WIDTH1COL * 2,
  height = HEIGHT1ROW * 3
)

fig.b = ggarrange(
  myplot.differences.all,
  myplot.differences.agg,
  ncol = 1,
  nrow = 2,
  labels = c('A', 'B')
)
#fig.a = ggarrange(fig.a1, fig.a2, ncol=1, nrow=2, heights = c(1, 1))

ggsave(
  filename = file.path(FIGS_DIR, "Parameters.png"),
  plot = fig.b,
  dpi = DPI,
  width = WIDTH1COL * 2,
  height = HEIGHT1ROW * 2
)


fig.c = ggarrange(
  myplot.range.group,
  myplot.range.agg,
  myplot.key.rt.group,
  myplot.key.rt.agg,
  ncol = 2,
  nrow = 2,
  labels = c('A', 'B', 'C', 'D')
)
ggsave(
  filename = file.path(FIGS_DIR, "Ratings.png"),
  plot = fig.c,
  dpi = DPI,
  width = WIDTH1COL * 2,
  height = HEIGHT1ROW * 2
)

fig.d = ggarrange(plotlist = myplots.list,
                  ncol = 5,
                  nrow = 2)

ggsave(
  filename = file.path(FIGS_DIR, "Associations.png"),
  plot = fig.d,
  dpi = DPI,
  width = WIDTH1COL * 5,
  height = HEIGHT1ROW * 2
)

mytheme = theme_classic(base_size = 11) + theme(legend.position = 'bottom', legend.title = element_blank())
theme_set(mytheme)


fig.e = ggarrange(plotlist = myplots.list[c(2, 7, 9, 10)],
                  ncol = 1,
                  nrow = 4)

ggsave(
  filename = file.path(FIGS_DIR, "SigAssociationsVert.png"),
  plot = fig.e,
  dpi = DPI,
  width = WIDTH1COL * 2,
  height = HEIGHT1ROW * 4
)


ggsave(
  filename = file.path(FIGS_DIR, "ParameterCorrelations.png"),
  plot = myplot.pairs,
  dpi = DPI,
  width = WIDTH1COL * 2,
  height = HEIGHT1ROW * 2
)

print(fig.a)
print(fig.b)
print(fig.c)
print(fig.d)

# if (init100) {
# 
# fig.e = ggarrange(
#   myplot.RT.choice.group,
#   myplot.RT.choice.agg,
#   myplot.choiceprob.group,
#   myplot.choiceprob.agg,
#   myplot.choiceprob.diff.group,
#   myplot.choiceprob.diff.agg,
#   ncol = 2,
#   nrow = 3,
#   labels = c('A', 'B', 'C', 'D', 'E', 'F')
# )


#ggsave(
#  filename = file.path(FIGS_DIR, "Choices_100.png"),
#   plot = fig.e,
#   dpi = DPI,
#   width = WIDTH1COL * 2,
#   height = HEIGHT1ROW * 3
# )
# 
# print(fig.e)
#}

```



# Table for the regressions
```{r Regression table}

# choices
choice.nogroup.labels = unlist(reg_labels[rownames(choice.nogroup.fixef)])
choice.nogroup.fixef = apply(choice.nogroup.fixef, 2, reformat)
choice.nogroup.fixef = as.data.frame(choice.nogroup.fixef)
choice.nogroup.fixef = data.frame(Predictor = choice.nogroup.labels, choice.nogroup.fixef)
choice.nogroup.fixef = add_ci_column(choice.nogroup.fixef)

choice.labels = unlist(reg_labels[rownames(choice.fixef)])
choice.fixef = apply(choice.fixef, 2, reformat)
choice.fixef = as.data.frame(choice.fixef)
choice.fixef = data.frame(Predictor = choice.labels, choice.fixef)
choice.fixef = add_ci_column(choice.fixef)

# rt
rt.nogroup.labels = unlist(reg_labels[rownames(rt.nogroup.fixef)])
rt.nogroup.fixef = apply(rt.nogroup.fixef, 2, reformat)
rt.nogroup.fixef = as.data.frame(rt.nogroup.fixef)
rt.nogroup.fixef = data.frame(Predictor = rt.nogroup.labels, rt.nogroup.fixef)
rt.nogroup.fixef = add_ci_column(rt.nogroup.fixef)

rt.labels = unlist(reg_labels[rownames(rt.fixef)])
rt.fixef = apply(rt.fixef, 2, reformat)
rt.fixef = as.data.frame(rt.fixef)
rt.fixef = data.frame(Predictor = rt.labels, rt.fixef)
rt.fixef = add_ci_column(rt.fixef)

rt.cor.labels = unlist(reg_labels[rownames(rt.cor.fixef)])
rt.cor.fixef = apply(rt.cor.fixef, 2, reformat)
rt.cor.fixef = as.data.frame(rt.cor.fixef)
rt.cor.fixef = data.frame(Predictor = rt.cor.labels, rt.cor.fixef)
rt.cor.fixef = add_ci_column(rt.cor.fixef)

#statslist['_table_choice.fixef_'] = tab_to_str(choice.fixef[, c(1,2,4,5)])
#statslist['_table_rt.fixef_'] = tab_to_str(rt.fixef[, c(1,2,5,4,6)])
#statslist['_table_rt.cor.fixef_'] = tab_to_str(rt.cor.fixef[, c(1,2,5,4,6)])

statslist['_table_choice.fixef_'] = tab_to_str(choice.fixef)
statslist['_table_rt.fixef_'] = tab_to_str(rt.fixef)
statslist['_table_rt.cor.fixef_'] = tab_to_str(rt.cor.fixef)

```

# Write results

```{r Write results}
filein = '../results/results_text.txt'
fileout = '../results/results_text_fixed.txt'
# fileout = ifelse(!init100, 
#   '../results/results_text_fixed.txt',
#   '../results/results_text_fixed_100.txt')

mytext = readLines(filein)
print(statslist)
text.new = NULL
placeholders = names(statslist)
for (line in mytext){ 
for (placeholder in placeholders){
  print(placeholder)
  line = gsub(placeholder, replacement = statslist[placeholder], line)
}
text.new = c(text.new, line)

}
unlink(fileout)
writeLines(text.new, con = fileout)
```


```{r}
convergelist_df <- as.data.frame(do.call(rbind, convergelist))
convergelist_df <- convergelist_df %>%mutate(rhat_max = unlist(rhat_max), ess_min = unlist(ess_min), tail_ess_min = unlist(tail_ess_min))
print(convergelist_df)
```

```{r Save all 6}
save.image(file = paste0(IMAGE_FILE, "_6.RData"))
```

