model {
    # Drift
        b.drift.intercept.mu ~ dnorm(0, 3)
        #b.drift.amount.mu ~ dnorm(0, 2)
        b.drift.intercept.sd ~ dgamma(1, 0.5)
        #b.drift.amount.sd ~ dgamma(1, 0.5)

   	# Boundary
        boundary.mu ~ dnorm(2, pow(1,-2))T(0.1, 10)
        boundary.sd ~ dgamma(1,1)
        
   	# Non-decision time
        nondectime.mu ~ dnorm(.5, pow(.25,-2))T(0.01, 5)
        nondectime.sd ~ dgamma(.3,1)

   	# Bias
        bias.mu ~ dnorm(.5, pow(.25,-2))T(0, 1)
        bias.sd ~ dgamma(.3,1)

    for (p in 1:N) { # subject level

        b.drift.intercept.p[p] ~ dnorm(b.drift.intercept.mu, pow(b.drift.intercept.sd,-2))
        #b.drift.amount.p[p] ~ dnorm(b.drift.amount.mu, pow(b.drift.amount.sd,-2))
        boundary.p[p] ~ dnorm(boundary.mu, pow(boundary.sd,-2))T(0.1, 10)
        nondectime.p[p] ~ dnorm(nondectime.mu, pow(nondectime.sd,-2))T(0.01, 5)
        bias.p[p] ~ dnorm(bias.mu, pow(bias.sd,-2))T(0, 1)

    }

    for (i in 1:M) { # trial level

        ## WIENER model, fixing the threshold to 2 and estimating the noise
#        RT.signed[i] ~ dwieners(boundary[i], nondectime[i], bias[i], drift[i], 1) 
#        RT.signed[i] ~ dwieners(boundary[i], 0.8, 0.5, 0, 1) 

        # generate predictions
        #RT.signed_pred[i] ~ dwieners(boundary[i], nondectime[i], bias[i], drift[i], 1) 

        # generate trial-by-trial parameters
        bias[i] <- bias.p[instance[i]]
        boundary[i] <- boundary.p[instance[i]]
        nondectime[i] <- nondectime.p[instance[i]]
        drift[i] <- b.drift.intercept.p[instance[i]] # + b.drift.amount.p[instance[i]]*amount_later_centered[i] 

    }
}

